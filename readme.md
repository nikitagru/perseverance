# Поиск кратчайшего пути
### Реализация алгоритма А*(А со звездой)

---

В качестве объекта перемещения выступает марсоход, который может двигаться только в соседние клетки по горизонали и вертикали.

На вход поступает двумерный массив `char[][]` размером KxL (1<=K,L<=10000)
* `#`  преграда
* `.` дорога
* `@` начальная точка
* `X` конечная точка

Основная функция `findRoute(char[][])` описана в интерфейсе RouteFinder:
````
/***
 * Интерфейс поиска маршрута
 */
public interface RouteFinder {
    /***
     * Поиск кратчайшего маршрута между двумя точками
     * @param map карта
     * @return карта с построенным маршрутом
     */
    char[][] findRoute(char[][] map) throws NoStartPositionException, NoGoalPositionException, IllegalSymbolException;
}
````

#### Реализует данный интерфейс класс RouteFinderImpl.

`private HashMap<Pair<Integer, Integer>,Pair<Integer, Integer>> cameFrom` - словарь всех предшественников, где по ключу хранится вершина, а по значению ее предшественник.


`private HashMap<Pair<Integer, Integer>, Integer> costToPoint` - словрь стоимости перемещения к точке, где по ключу хранится точка, а по значению стоимость перемещения.

* `public char[][] findRoute(char[][] map)` - основной метод, который ищет маршрут с помощью алгоритма А*


* `private char[][] createRoute(Map map, HashMap<Pair<Integer, Integer>, Pair<Integer, Integer>> cameFrom)` - создает массив с маршрутом, используя объект карты и словарь предшественников


#### Класс объекта карты `Map`:

Класс можно расширить, добавив в карту поверхности с разной степенью проходимости.

`private Pair<Integer, Integer> startPosition` - стартовая позиция марсохода
`private Pair<Integer, Integer> goalPosition` - конечная точка
* в конструкторе происходит создание карты и в виде двумерного массива `int[][] map` , получаемый из исходого массива `char[][]`. Проходит проверка карты на ошибки. Каждому числу в массиве `int[][] map` соответствует определенная поверхность/объект:
    * `.` - 1 (обычное поле, по которому может перемещаться марсоход)
    * `@` - 2 (стартовая точка марсохода)
    * `X` - 0 (конечная точка)
    * `#` - 3 (стена, через которую робот не может пройти)
    

* `public List<Pair<Integer, Integer>> getNeighbors(Pair<Integer, Integer> point)` - метод поиска всех соедей у точки `point` с проверкой на наличие стен и выхода за границы карты.


* `public int distanceToGoal(Pair<Integer, Integer> point)` - метод вычисления рассояния от точки `point` до конечной точки. Вычисление происходит по формуле Манхэттеновского расстояния.



#### Класс очереди с приоритетом `PairPriorityQueue`:

Класс обертка над страндарной очередью с приоритетами из java. 


`private PriorityQueue<Pair<Pair<Integer, Integer>, Integer>> queue` - стандартная очередь с приоритетами, где хранится точка и число ее приоритета.


Конструктор очереди, где в качестве сравнения используется второе значение("приоритет" точки, вычисляемый в методе `findRoute` из класса RouteFinderImpl).
````
public PairPriorityQueue() {
        this.queue = new PriorityQueue<>(Comparator.comparingInt(Pair::getValue1));
    }
````

##### Как работает приоритет:



На каждой итерации в методе `findRoute` (во время поиска соседей) происходит вычисление приоритета, который состоит из суммы перемещения к точке и Манхэттеновского расстояния до конечной точки. Самой приоритетной является та, которая имеет меньшее число приоритета.



* `public void add(Pair<Pair<Integer, Integer>, Integer> value)` - метод добавления в очередь точки


* ` public Pair<Pair<Integer, Integer>, Integer> poll()` - извлечение самой приоритетной точки из очереди.

